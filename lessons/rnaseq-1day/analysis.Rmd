---
layout: page
---

```{r, echo=FALSE, message=FALSE, eval=TRUE}
# Set eval=TRUE here to hide all results and figures.
# This sets defaults. Can change this manually in individual chunks.
# Must load knitr so opts_chunk is in search path.
library(knitr)
opts_chunk$set(results="hide", message=FALSE, fig.show="hide", fig.keep="none", tidy=TRUE)
```

# RNA-seq data analysis

This is an introduction to RNAseq analysis involving reading in count data from an RNAseq experiment, exploring the data using base R functions and then analysis with the DESeq2 package.

## Install required CRAN packages

First, install some packages that you'll use. You only have to do this once, but you'll need to load them each time you start a new R session.

```{r install_packages, eval=FALSE}
install.packages("gplots")
install.packages("ggplot2")
install.packages("calibrate")
```

## Introduction and data import

Analyzing an RNAseq experiment begins with sequencing reads. These are aligned to a reference genome, then the number of reads mapped to each gene can be counted. 

The data for this tutorial comes from a PLOS ONE paper, [Genome-Wide Transcriptional Profiling of Skin and Dorsal Root Ganglia after Ultraviolet-B-Induced Inflammation](http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0093338), and the raw data can be downloaded from [Gene Expression Omnibus database (GEO)](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE54413). 

This data has already been downloaded and aligned to the human genome. The command line tool [featureCounts](http://bioinf.wehi.edu.au/featureCounts/) was used to count reads mapped to human genes from the [Ensembl annotation](http://www.ensembl.org/info/data/ftp/index.html). 

The output from this tool is provided in the `counts.txt` file in the `data` directory. Have a look at this file in the shell, using `head`.

First, set your working directory to the top level of the RNA-seq course. Import the data into R as a `data.frame` and examine it again. You can set the arguments of `read.table` to import the first row as a header giving the column names, and the first column as row names. 

```{r data_input}
# Filename with output from featureCounts
countfile <- "data/counts.txt"
# Read in the data
countdata <- read.table(countfile, header=TRUE, row.names=1)
head(countdata)
colnames(countdata)
class(countdata)
```

The data.frame contains information about genes (one gene per row) with the gene positions in the first five columns and then information about the number of reads aligning to the gene in each experimental sample. There are three replicates for control (column names starting with "ctl") and three for samples treated with ultraviolet-B light (starting "uvb"). We don't need the information on gene position for this analysis, just the counts for each gene and sample, so we can remove it from the data frame.

```{r remove_metadata_cols}
# Remove first five columns (chr, start, end, strand, length)
countdata <- countdata[ ,-(1:5)]
head(countdata)
colnames(countdata)
```

We can rename the columns to something shorter and a bit more readable. 

```{r bad_renaming, eval=FALSE}
# Manually
c("ctl1", "ctl2", "ctl3", "uvb1", "uvb2", "uvb3")
```

We can do it manually, but what if we have 600 samples instead of 6? This would become cumbersome. Also, it's always a bad idea to hard-code sample phenotype information at the top of the file like this. A better way to do this is to use the `gsub` command to strip out the extra information. This more robust to introduced errors, for example if the column order changes at some point in the future or you add additional replicates. 

```{r rename_cols}
# Using gsub -- robust
?gsub
gsub(pattern="trimmed_|.fastq_tophat.accepted_hits.bam", replacement="", x=colnames(countdata))
colnames(countdata) <- gsub(pattern="trimmed_|.fastq_tophat.accepted_hits.bam", replacement="", x=colnames(countdata))
head(countdata)
```

---

**EXERCISE**

There's an R function called `rowSums()` that calculates the sum of each row in a numeric matrix, like the count matrix we have here, and it returns a vector. There's also a function called `which.max()` that determines the index of the maximum value in a vector.

0. Find the gene with the highest expression across all samples -- remember, each row is a gene. 
0. Extract the expression data for this gene for all samples. 
0. In which sample does it have the highest expression? 
0. What is the function of the gene? Can you suggest why this is the top expressed gene?

```{r, echo=FALSE, include=FALSE}
topGene <- which.max(rowSums(countdata))
topGene
countdata[topGene, ]
# this is a pseudogene - maybe an artefact of only aligning reads to a single chromosome?
```

---

## Data investigation using base R

We can investigate this data a bit more using some of the basic R functions before going on to use more sophisticated analysis tools.

First make a copy of the data, because we'll need it later. We will work on the copy. We will calculate the mean for each gene for each condition and plot them.

```{r get_means}
cd2 <- countdata #make a copy

# get Control columns
colnames(cd2)

# grep searches for matches to a pattern 
?grep 

# get the indexes for the controls
grep("ctl", colnames(cd2))
ctlCols <- grep("ctl", colnames(cd2))
head(cd2[,ctlCols])

# use the rowMeans function
cd2$ctlmean <- rowMeans(cd2[, ctlCols])
head(cd2)

# same for uvb
uvbCols <- grep("uvb", colnames(cd2))
cd2$uvbmean <- rowMeans(cd2[, uvbCols])

head(cd2)
```

---

**EXERCISE**

Using the `subset()` function, print out all the columns where the control mean does not equal 0 **and** where the UVB mean does not equal zero.

Bonus: code golf -- use the fewest characters to get the same solution.

```{r, echo=FALSE, include=FALSE}
subset(cd2, ctlmean>0 & uvbmean>0)
subset(cd2, ctlmean*uvbmean>0)
```

---

---

**EXERCISE**

0. Plot the mean expression of each gene in control against the UVB sample mean. Are there any outliers?
0. How could you make this plot more informative and look more professional? Hint: try plotting on the log scale and using a different point character.

```{r plot_means}
plot(cd2$ctlmean, cd2$uvbmean)
with(cd2, plot(log10(ctlmean), log10(uvbmean), pch=16))
with(cd2, plot(ctlmean, uvbmean, log="xy", pch=16))
```

---

## Poor man's differential gene expression

We can find candidate differentially expressed genes by looking for genes with a large change between control and UVB samples. A common threshold used is log2 fold change more than 2 or less than -2. We will calculate log2 fold change for all the genes and colour the genes with log2 fold change of more than 2 or less than -2 on the plot.

First, check for genes with a mean expression of 0. Putting zeroes into the log2 fold change calculation will produce NAs, so we might want to remove these genes. Note: this is for mathematical reasons, although different software may produce different results when you try to do `log2(0)`.

```{r count_expressed}
head(cd2$ctlmean)
head(cd2$ctlmean > 0)
```

In R, `TRUE` and `FALSE` can be represented as `1` and `0`, respectively. When we call `sum(cd2$ctlmean > 0)`, we're really asking, "how many genes have a mean above 0 in the control group?"

```{r remove_unexpressed}
sum(cd2$ctlmean > 0)
sum(cd2$uvbmean > 0)
```

Now, let's subset the data and keep things where either the control or UVB group means are greater than zero.

```{r subset_nonzero}
nrow(cd2)
cd2 <- subset(cd2, cd2$ctlmean > 0 | cd2$uvbmean > 0)
nrow(cd2)
head(cd2)
```

Mathematically things work out better for us when we test things on the log scale. On the absolute scale, upregulation goes from 1 to infinity, while downregulation is bounded by 0 and 1. On the log scale, upregulation goes from 0 to infinity, and downregulation goes from 0 to negative infinity. Let's compute a log-base-2 of the fold change.

When we do this we'll see some `Inf` and `-Inf` values. This is what happens when we take `log2(Inf)` or `log2(0)`.

```{r log2FC}
# calculate the log2 fold change
cd2$log2FC <- log2(cd2$uvbmean / cd2$ctlmean)
head(cd2)

# see how many are up, down, or both (using the absolute value function)
sum(cd2$log2FC > 2)
sum(cd2$log2FC < -2)
sum(abs(cd2$log2FC)>2)
```

We can few just the "outliers" with `subset(cd2, abs(log2FC)>2)`, which gets us just the things that have a large fold change in either direction. Let's plot these.

```{r plot_outliers}
with(cd2, plot(ctlmean, uvbmean, log="xy", pch=16))
subset(cd2, abs(log2FC)>2)
# use the points function to add more points to the same axes
with(subset(cd2, abs(log2FC)>2), points(ctlmean, uvbmean, pch=16, col="red"))
```

What do you notice about the positions of the outliers on these plots? How would you interpret this? What are some of the problems with this simple approach?

## DESeq2 analysis

DESeq2 is an R package for analysis of RNAseq data. It is available from [Bioconductor](http://www.bioconductor.org/). Bioconductor is a project to provide tools for analysing high-throughput genomic data including RNA-seq, ChIP-seq and arrays. You can explore Bioconductor packages [here](http://www.bioconductor.org/packages/release/BiocViews.html#___Software). 

```{r install_deseq2, eval=FALSE}
# install and have a break to check everyone is up to date?
# explain bioconductor?
source("http://bioconductor.org/biocLite.R")
biocLite("DESeq2")
```

```{r load_deseq2}
library("DESeq2")
citation("DESeq2")
```

It requires the count data to be in matrix form, and an additional dataframe describing the structure of the experiment.

```{r convert_to_matrix}
# countdata is currently a data.frame, but DESeq2 expects its input to be in 
# matrix format, so we will convert our countdata to a matrix.
class(countdata)
countdata <- as.matrix(countdata)
class(countdata)
head(countdata)

# construct colData dataframe
# three replicates of control and UVB.
colData <- data.frame(condition=c(rep("ctl", 3), rep("uvb",3)), row.names=colnames(countdata))
```

DESeq works on a particular type of object called a DESeqDataSet.

```{r make_deseqdataset}
# introduce how DESeq2 works - type of object it works on etc
# instantiate the DESeqDataSet
dds <- DESeqDataSetFromMatrix(countdata=countdata, colData=colData, design=~condition)
dds
```

Run the DESeq pipeline on this object. [Describe pipeline steps?]
Get results and have a look at them

```{r run_deseq}
dds <- DESeq(dds)

# Get differential expression results
res <- results(dds)
head(res)
table(res$padj<0.05)
# Order by adjusted p-value
res <- res[order(res$padj), ]
head(res)
```

Combine DEseq results with the original counts data. Write significant results to a file.

```{r write_results}
resData <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
head(resData)
names(resData)[1] <- "GeneID"
head(resData)

sig <- subset(resData, padj<0.05)
dir.create("results")
write.table(sig, file="results/sig.txt", sep="\t") # tab delim data
```

You can open this file in Excel or any text editor (try it now).

## Data Visualization

We can also do some exploratory plotting of the data.

```{r plot_dispersion}
plotDispEsts(dds, main="Dispersion plot")
```

```{r plot_heatmaps}
# Regularized log transformation for clustering/heatmaps, etc
rld <- rlogTransformation(dds)
plotPCA(rld)

# Sample distance heatmap
head(assay(rld))
assay(rld)[1:5,1:5]
t(assay(rld))[1:5,1:5]
dist(t(assay(rld)))
as.matrix(dist(t(assay(rld))))
sampleDists <- as.matrix(dist(t(assay(rld))))
heatmap(sampleDists)
# better heatmap with gplots
library("gplots")
heatmap.2(sampleDists)
heatmap.2(sampleDists, col=colorpanel(64, "steelblue", "white"), key=FALSE, trace="none")
heatmap.2(sampleDists, col=colorpanel(64, "black", "white"), key=FALSE, trace="none")
heatmap.2(sampleDists, col=colorpanel(64, "red", "black", "green"), key=FALSE, trace="none")
heatmap.2(sampleDists, col=colorpanel(64, "red", "white", "blue"), key=FALSE, trace="none")
```

```{r plot_pval_hist}
# Examine plot of p-values
hist(res$pvalue, breaks=50, col="grey")
```


```{r MA_plot}
# These are the plots that are most recognisable from papers
# MA Plot
par(pch=16)
with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x"))
with(subset(res, padj<.05), points(baseMean, log2FoldChange, col="red", pch=16))
library("calibrate")
?textxy
res$Gene <- rownames(res)
with(subset(res, padj<.05), textxy(baseMean, log2FoldChange, labs=Gene, cex=1, col=2))
```

```{r volcano_plot}
# Volcano plot
# Set point character
par(pch=16)
with(res, plot(log2FoldChange, -log10(pvalue), main="Volcano plot"))
with(subset(res, padj<.05 ), points(log2FoldChange, -log10(pvalue), col="red"))
with(subset(res, abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), col="orange"))
with(subset(res, padj<.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), col="green"))
# Add legend
legend("topleft", legend=c("FDR<0.05", "|LFC|>1", "both"), pch=16, col=c("red","orange","green"))
# Label points
with(subset(res, padj<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=1))
```

